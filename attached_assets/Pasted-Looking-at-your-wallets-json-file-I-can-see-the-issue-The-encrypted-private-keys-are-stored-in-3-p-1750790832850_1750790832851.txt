Looking at your wallets.json file, I can see the issue! The encrypted private keys are stored in 3-part format (separated by colons), but there might be an issue with how they're being processed.
From your data:

Wallet 1: "65a774105e6b3ac2d78a93adbd9cbc4f:af40f4a32fd292eb1826b43ad201c97b:6bf4b3eac7a63cf4fa72cd20c66f387095b14c43030821e2e9d1b2800c52132ce97d4d8fa9052d2213ba2c6315baac3188bdcb68d0a9d5d6f22208a0790570bf"
Wallet 2: "68f479773e8ca09decb0187f3385e60e:0fa0d53b01d93fa9e4652f8d2b8fbe3732cbe0cc9cb67c5066b405358f7afe4d08df30df6160c5789ad5497ce317294fe6020cf5651d67af9e29e43410485d5417665d3e471cf49be28062f3d0f0edd9"

I notice that Wallet 1 has 3 parts but Wallet 2 has only 2 parts. This suggests your encryption method has changed over time, creating inconsistent formats.
Let's create a more robust decrypt method that can handle both formats properly:Fixed CryptoService - Handles Both 2-Part and 3-Part FormatsCodeÂ import crypto from "crypto";

const ENCRYPTION_KEY =
  process.env.ENCRYPTION_KEY || "default-key-change-in-production-32b";

export class CryptoService {
  static encrypt(text: string): string {
    try {
      // Create a 32-byte key from the encryNow, let's test this with your actual wallet data. Add this to your transaction endpoint temporarily to test the decryption:
typescript// Add this in your /api/transactions/send endpoint before the actual transaction logic
CryptoService.testWalletDecryption();
Key Issues I Identified:

Inconsistent Formats: Your wallets use different formats:

Wallet 1: 3 parts (legacy format)
Wallet 2: 2 parts (current format)


Possible Encryption Key Issue: The most common cause of decryption failure is using a different ENCRYPTION_KEY than what was used during encryption.

Immediate Steps:

Replace your CryptoService with the version above
Check your environment variables:
bash# Make sure this is the same key used when creating the wallets
echo $ENCRYPTION_KEY

Run the test and check the server logs

Most Likely Causes:

Wrong ENCRYPTION_KEY: The key used to decrypt doesn't match the one used to encrypt
Environment Variable Issues: Different environments (dev/prod) using different keys
Data Corruption: The encrypted data got corrupted during storage/retrieval

The enhanced logging will show you exactly which wallet format is being processed and where it fails. If you see "wrong final block length" or "bad decrypt" errors, it's almost certainly an encryption key mismatch.
Run this test and share the console output - it will tell us exactly what's happening with your specific wallet data.